// sean at shanghai
// this project runs code at
// https://doc.rust-lang.org/rust-by-example/

use std::fmt;

// This declaration will look for a file named `inner.rs` or `inner/mod.rs` and will
// insert its contents inside a module named `my` under this scope
mod inner;

// use librarty.rlib generated by rary.rs
// rustc main.rs --extern rary=library.rlib
extern crate rary;

// fmt shows all kinds of print functions
fn fmt_print() {
    println!("{} days", 31);
    println!("{0}, this is {1}, {1}, this is {0}", "alice", "bob");
    println!(
        "{sub} {verb} {obj}",
        obj = "the lazy dog",
        sub = "the quick brown fox",
        verb = "jumps over"
    );
    println!(
        "{} of {:b} people know binary, the other half does not",
        1, 2
    );
}

#[derive(Debug)]
struct Person<'a> {
    name: &'a str,
    age: u8,
}

// debug print a struct derive from Debug
// but Display should implement manually
fn debug() {
    let name = "Peter";
    let age = 27;
    let peter = Person { name, age };
    println!("{:#?}", peter);
}

struct Struct(i32);
// impl for display
impl fmt::Display for Struct {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

// for loop
fn for_loop() {
    for n in 1..10 {
        println!("{} is", n);
    }
}

// function input and output
// Fn() means it should be a function
fn call_me<F: Fn()>(f: F) {
    f();
}

// function takes no argument
fn f() {
    println!("I'm a function!");
}

// caller calls tow types of functions
fn caller() {
    let closure = || println!("I am a closure!");
    call_me(closure);
    call_me(f);
}

// create_fn generate a function and return
fn create_fn() -> impl Fn() {
    let text = "Fn".to_owned();
    // ?? what does move do?
    move || println!("This is a: {}", text)
}

// create_fnmut we can mutate text
fn create_fnmut() -> impl FnMut() {
    let text = "FnMut".to_owned();

    move || println!("This is a: {}", text)
}

// this one cloud only be called once
fn create_fnonce() -> impl FnOnce() {
    let text = "FnOnce".to_owned();

    move || println!("This is a: {}", text)
}

// calls all of them
fn fn_caller() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();
    let fn_once = create_fnonce();

    fn_plain();
    fn_mut();
    fn_once();
}

// is_odd for higher order functions
fn is_odd(n: u32) -> bool {
    n % 2 == 1
}

// high_order_fn calls is_odd
fn high_order_fn() {
    println!("Find the sum of all the squared odd numbers under 1000");
    let upper = 1000;
    // Imperative approach
    // Declare accumulator variable
    let mut acc = 0;
    // Iterate: 0, 1, 2, ... to infinity
    for n in 0.. {
        // Square the number
        let n_squared = n * n;

        if n_squared >= upper {
            // Break loop if exceeded the upper limit
            break;
        } else if is_odd(n_squared) {
            // Accumulate value, if it's odd
            acc += n_squared;
        }
    }
    println!("imperative style: {}", acc);

    // Functional approach
    let sum_of_squared_odd_numbers: u32 = (0..)
        .map(|n| n * n) // All natural numbers squared
        .take_while(|&n_squared| n_squared < upper) // Below upper limit
        .filter(|&n_squared| is_odd(n_squared)) // That are odd
        .fold(0, |acc, n_squared| acc + n_squared); // Sum them
    println!("functional style: {}", sum_of_squared_odd_numbers);
}

fn main() {
    fmt_print();
    debug();
    for_loop();
    caller();
    fn_caller();
    high_order_fn();
    inner::fn_list::mod_fn();
    rary::public_fn();
}
